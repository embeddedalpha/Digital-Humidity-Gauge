/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "Console/Console.h"
#include "I2C/I2C.h"
#include "GPIO/GPIO.h"
#include "BME280.h"
#include "Humidity_Gauge/Humidity_Gauge.h"

I2C_Config BME280;

typedef enum
{
	UNIT_CELSIUS = 0,
	UNIT_FAHRENHEIT = 1
} DisplayUnit;

volatile DisplayUnit currentUnit = UNIT_CELSIUS;


typedef enum
{
	Page_0 = 0,
	Page_1,
	Page_2,
	Page_3,
	Page_4,
}DisplayPage;

volatile DisplayPage currentPage = Page_0;

void Hold_Button_ISR(void)
{

}

void Degree_Button_ISR(void)
{
    currentUnit = (currentUnit == UNIT_CELSIUS)
                  ? UNIT_FAHRENHEIT
                  : UNIT_CELSIUS;

}

void Reset_Button_ISR(void)
{

}

void Top_Arrow_Button_ISR(void)
{
	currentPage = (DisplayPage)((currentPage + 1) % 5);
}


void Bottom_Arrow_Button_ISR(void)
{
	currentPage = (DisplayPage)((currentPage + 4) % 5);
}


int main(void)
{
	MCU_Clock_Setup();

	GPIO_Pin_Init(GPIOA, 5, GPIO_Configuration.Mode.Input, GPIO_Configuration.Output_Type.Open_Drain, GPIO_Configuration.Speed.None, GPIO_Configuration.Pull.Pull_Down, GPIO_Configuration.Alternate_Functions.None);
	GPIO_Interrupt_Setup(GPIOA, 5, GPIO_Configuration.Interrupt_Edge.RISING_EDGE, 0, Hold_Button_ISR);

	GPIO_Pin_Init(GPIOA, 6, GPIO_Configuration.Mode.Input, GPIO_Configuration.Output_Type.Open_Drain, GPIO_Configuration.Speed.None, GPIO_Configuration.Pull.Pull_Down, GPIO_Configuration.Alternate_Functions.None);
	GPIO_Interrupt_Setup(GPIOA, 6, GPIO_Configuration.Interrupt_Edge.RISING_EDGE, 0, Degree_Button_ISR);

	GPIO_Pin_Init(GPIOA, 7, GPIO_Configuration.Mode.Input, GPIO_Configuration.Output_Type.Open_Drain, GPIO_Configuration.Speed.None, GPIO_Configuration.Pull.Pull_Down, GPIO_Configuration.Alternate_Functions.None);
	GPIO_Interrupt_Setup(GPIOA, 7, GPIO_Configuration.Interrupt_Edge.RISING_EDGE, 0, Reset_Button_ISR);


	GPIO_Pin_Init(GPIOA, 8, GPIO_Configuration.Mode.Input, GPIO_Configuration.Output_Type.Open_Drain, GPIO_Configuration.Speed.None, GPIO_Configuration.Pull.Pull_Down, GPIO_Configuration.Alternate_Functions.None);
	GPIO_Interrupt_Setup(GPIOA, 8, GPIO_Configuration.Interrupt_Edge.RISING_EDGE, 0, Top_Arrow_Button_ISR);

	GPIO_Pin_Init(GPIOA, 9, GPIO_Configuration.Mode.Input, GPIO_Configuration.Output_Type.Open_Drain, GPIO_Configuration.Speed.None, GPIO_Configuration.Pull.Pull_Down, GPIO_Configuration.Alternate_Functions.None);
	GPIO_Interrupt_Setup(GPIOA, 9, GPIO_Configuration.Interrupt_Edge.RISING_EDGE, 0, Bottom_Arrow_Button_ISR);




	BME280.Port = I2C1;
	BME280.SCL_Pin = I2C_Configuration.Pin.__I2C1__.SCL.PB6;
	BME280.SDA_Pin = I2C_Configuration.Pin.__I2C1__.SDA.PB7;
	BME280.Speed_Mode = I2C_Configuration.Speed_Mode.FM_Mode;
	BME280.Mode = I2C_Configuration.Mode.Master;
	BME280.Interrupts_Enable = I2C_Configuration.Interrupts_Enable.Disable;
	BME280.DMA_Control = I2C_Configuration.DMA_Control.RX_DMA_Enable;

	I2C_Init(&BME280);


	// Read ID

	BME280_Init(&BME280);

	bme280_raw raw_values;

	BME280_Get_Raw(&BME280, &raw_values);


	float T_C  = BME280_Compensate_T(raw_values.Temperature_Raw) * 0.01f;
	float P_kPa= BME280_Compensate_P(raw_values.Pressure_Raw) / 1000.0f;
	float RH   = BME280_Compensate_H(raw_values.Humidity_Raw) / 1024.0f;


	psychro_t Data;




	for(;;)
	{

		if(currentUnit == UNIT_FAHRENHEIT)
		{

		}
		else
		{
			Data = psychro_from_bme280(T_C, RH, P_kPa);
		}



	}
}


